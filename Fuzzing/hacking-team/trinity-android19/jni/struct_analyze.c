/***** Automatically generated by gen_recursive.c *********/

#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <libxml/xmlwriter.h>
#include <libxml/encoding.h>
#include <sys/times.h>
#include <sched.h>
#include <linux/kexec.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/vfs.h>
#include <sys/syscall.h>
#include <linux/aio_abi.h>
#include <unistd.h>
#include <utime.h>
#include <dirent.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <poll.h>
#include <sys/epoll.h>
#include <sys/utsname.h>
#ifdef LOLLIPOP
#include <sys/msg.h>
#include <sys/timex.h>
#endif
#include <sys/ipc.h>
#include <linux/shm.h>
#include <linux/futex.h>
#include <linux/fs.h>
#include <linux/sysctl.h>

#include "struct_analyze.h"
#include "syscall.h"
#include "ioctl_types.h"

int nullfd = 0;

void struct_recursive_analyze(void *arg_ptr, bool is_ioctl_call, enum ioctl_struct_type ioctl_struct_type, enum struct_argtype struct_argtype, xmlTextWriterPtr writer) {

if(arg_ptr == NULL)
return;
if(nullfd == 0)
nullfd = open("/dev/random", O_WRONLY);

if(is_ioctl_call == TRUE) {
switch(ioctl_struct_type) {
struct venc_ioctl_msg *p0;
struct qseecom_register_listener_req *p1;
struct qseecom_send_cmd_req *p2;
struct qseecom_ion_fd_info *p3;
struct qseecom_send_modfd_cmd_req *p4;
struct qseecom_send_resp_req *p5;
struct qseecom_load_img_req *p6;
struct qseecom_set_sb_mem_param_req *p7;
struct qseecom_qseos_version_req *p8;
struct qseecom_qseos_app_load_query *p9;
struct kgsl_devinfo *p10;
struct kgsl_devmemstore *p11;
struct kgsl_shadowprop *p12;
struct kgsl_version *p13;
struct kgsl_ibdesc *p14;
struct kgsl_device_getproperty *p15;
struct kgsl_device_waittimestamp *p16;
struct kgsl_device_waittimestamp_ctxtid *p17;
struct kgsl_ringbuffer_issueibcmds *p18;
struct kgsl_cmdstream_readtimestamp *p19;
struct kgsl_cmdstream_freememontimestamp *p20;
struct kgsl_drawctxt_create *p21;
struct kgsl_map_user_mem *p22;
struct kgsl_cmdstream_readtimestamp_ctxtid *p23;
struct kgsl_cmdstream_freememontimestamp_ctxtid *p24;
struct kgsl_sharedmem_from_pmem *p25;
struct kgsl_sharedmem_free *p26;
struct kgsl_cff_user_event *p27;
struct kgsl_gmem_desc *p28;
struct kgsl_buffer_desc *p29;
struct kgsl_bind_gmem_shadow *p30;
struct kgsl_sharedmem_from_vmalloc *p31;
struct kgsl_drawctxt_set_bin_base_offset *p32;
struct kgsl_cmdwindow_write *p33;
struct kgsl_cff_syncmem *p34;
struct kgsl_timestamp_event *p35;
struct kgsl_timestamp_event_genlock *p36;
struct kgsl_timestamp_event_fence *p37;
struct kgsl_gpumem_alloc_id *p38;
struct kgsl_gpumem_free_id *p39;
struct kgsl_gpumem_get_info *p40;
struct kgsl_gpumem_sync_cache *p41;
struct kgsl_perfcounter_get *p42;
struct kgsl_perfcounter_put *p43;
struct kgsl_perfcounter_query *p44;
struct kgsl_perfcounter_read_group *p45;
struct kgsl_perfcounter_read *p46;
struct kgsl_drawctxt_destroy *p47;
struct kgsl_gpumem_alloc *p48;
struct mc_ioctl_init *p49;
struct mc_ioctl_info *p50;
struct mc_ioctl_map *p51;
struct mc_ioctl_reg_wsm *p52;
struct mc_ioctl_execute *p53;
struct mc_ioctl_resolv_cont_wsm *p54;
struct mc_ioctl_resolv_wsm *p55;
struct msm_jpeg_ctrl_cmd *p56;
struct msm_jpeg_buf *p57;
struct msm_jpeg_hw_cmd *p58;
struct msm_jpeg_hw_cmds *p59;
struct timespec *p60;
struct v4l2_capability *p61;
struct v4l2_fmtdesc *p62;
struct v4l2_rect *p63;
struct v4l2_clip *p64;
struct v4l2_window *p65;
struct v4l2_format *p66;
struct v4l2_requestbuffers *p67;
struct v4l2_timecode *p68;
struct v4l2_plane *p69;
struct timeval *p70;
struct v4l2_buffer *p71;
struct v4l2_plane_pix_format *p72;
struct v4l2_pix_format_mplane *p73;
struct v4l2_pix_format *p74;
struct v4l2_framebuffer *p75;
struct v4l2_streamparm *p76;
struct v4l2_fract *p77;
struct v4l2_standard *p78;
struct v4l2_input *p79;
struct v4l2_control *p80;
struct v4l2_tuner *p81;
struct v4l2_modulator *p82;
struct v4l2_audio *p83;
struct v4l2_queryctrl *p84;
struct v4l2_querymenu *p85;
struct v4l2_outputparm *p86;
struct v4l2_audioout *p87;
struct v4l2_frequency *p88;
struct v4l2_cropcap *p89;
struct v4l2_crop *p90;
struct v4l2_jpegcompression *p91;
struct v4l2_sliced_vbi_cap *p92;
struct v4l2_ext_controls *p93;
struct v4l2_frmsize_stepwise *p94;
struct v4l2_frmsizeenum *p95;
struct v4l2_frmival_stepwise *p96;
struct v4l2_frmivalenum *p97;
struct v4l2_enc_idx_entry *p98;
struct v4l2_enc_idx *p99;
struct v4l2_encoder_cmd *p100;
struct v4l2_dbg_match *p101;
struct v4l2_dbg_register *p102;
struct v4l2_dbg_chip_ident *p103;
struct v4l2_hw_freq_seek *p104;
struct v4l2_dv_enum_preset *p105;
struct v4l2_dv_preset *p106;
struct v4l2_dv_timings *p107;
struct v4l2_event *p108;
struct v4l2_event_subscription *p109;
struct v4l2_create_buffers *p110;
struct v4l2_selection *p111;
struct v4l2_decoder_cmd *p112;
struct v4l2_output *p113;
case STRUCT_undefined:

return;

case STRUCT_venc_ioctl_msg:
if(write(nullfd, (void *) arg_ptr, sizeof(struct venc_ioctl_msg)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_venc_ioctl_msg", "unmapped");
return;
 }

p0 = (struct venc_ioctl_msg *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_venc_ioctl_msg");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p0 , 0, sizeof(struct venc_ioctl_msg));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p0->in), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_in");
xmlTextWriterWriteBase64(writer, (char *) (p0->in), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_in", "unmapped");
// void pointer
if(write(nullfd, (void *)(p0->out), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_out");
xmlTextWriterWriteBase64(writer, (char *) (p0->out), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_out", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_register_listener_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_register_listener_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_register_listener_req", "unmapped");
return;
 }

p1 = (struct qseecom_register_listener_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_register_listener_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p1 , 0, sizeof(struct qseecom_register_listener_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_send_cmd_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_send_cmd_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_send_cmd_req", "unmapped");
return;
 }

p2 = (struct qseecom_send_cmd_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_send_cmd_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p2 , 0, sizeof(struct qseecom_send_cmd_req));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p2->cmd_req_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_cmd_req_buf");
xmlTextWriterWriteBase64(writer, (char *) (p2->cmd_req_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_cmd_req_buf", "unmapped");
// void pointer
if(write(nullfd, (void *)(p2->resp_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_resp_buf");
xmlTextWriterWriteBase64(writer, (char *) (p2->resp_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_resp_buf", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_ion_fd_info:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_ion_fd_info)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_ion_fd_info", "unmapped");
return;
 }

p3 = (struct qseecom_ion_fd_info *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_ion_fd_info");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p3 , 0, sizeof(struct qseecom_ion_fd_info));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_send_modfd_cmd_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_send_modfd_cmd_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_send_modfd_cmd_req", "unmapped");
return;
 }

p4 = (struct qseecom_send_modfd_cmd_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_send_modfd_cmd_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p4 , 0, sizeof(struct qseecom_send_modfd_cmd_req));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p4->cmd_req_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_cmd_req_buf");
xmlTextWriterWriteBase64(writer, (char *) (p4->cmd_req_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_cmd_req_buf", "unmapped");
// void pointer
if(write(nullfd, (void *)(p4->resp_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_resp_buf");
xmlTextWriterWriteBase64(writer, (char *) (p4->resp_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_resp_buf", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_send_resp_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_send_resp_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_send_resp_req", "unmapped");
return;
 }

p5 = (struct qseecom_send_resp_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_send_resp_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p5 , 0, sizeof(struct qseecom_send_resp_req));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p5->resp_buf), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_resp_buf");
xmlTextWriterWriteBase64(writer, (char *) (p5->resp_buf), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_resp_buf", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_load_img_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_load_img_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_load_img_req", "unmapped");
return;
 }

p6 = (struct qseecom_load_img_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_load_img_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p6 , 0, sizeof(struct qseecom_load_img_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_set_sb_mem_param_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_set_sb_mem_param_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_set_sb_mem_param_req", "unmapped");
return;
 }

p7 = (struct qseecom_set_sb_mem_param_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_set_sb_mem_param_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p7 , 0, sizeof(struct qseecom_set_sb_mem_param_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_qseos_version_req:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_qseos_version_req)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_qseos_version_req", "unmapped");
return;
 }

p8 = (struct qseecom_qseos_version_req *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_qseos_version_req");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p8 , 0, sizeof(struct qseecom_qseos_version_req));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_qseecom_qseos_app_load_query:
if(write(nullfd, (void *) arg_ptr, sizeof(struct qseecom_qseos_app_load_query)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_qseecom_qseos_app_load_query", "unmapped");
return;
 }

p9 = (struct qseecom_qseos_app_load_query *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_qseecom_qseos_app_load_query");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p9 , 0, sizeof(struct qseecom_qseos_app_load_query));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_devinfo:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_devinfo)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_devinfo", "unmapped");
return;
 }

p10 = (struct kgsl_devinfo *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_devinfo");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p10 , 0, sizeof(struct kgsl_devinfo));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_devmemstore:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_devmemstore)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_devmemstore", "unmapped");
return;
 }

p11 = (struct kgsl_devmemstore *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_devmemstore");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p11 , 0, sizeof(struct kgsl_devmemstore));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_shadowprop:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_shadowprop)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_shadowprop", "unmapped");
return;
 }

p12 = (struct kgsl_shadowprop *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_shadowprop");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p12 , 0, sizeof(struct kgsl_shadowprop));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_version:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_version)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_version", "unmapped");
return;
 }

p13 = (struct kgsl_version *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_version");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p13 , 0, sizeof(struct kgsl_version));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_ibdesc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_ibdesc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_ibdesc", "unmapped");
return;
 }

p14 = (struct kgsl_ibdesc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_ibdesc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p14 , 0, sizeof(struct kgsl_ibdesc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p14->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p14->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_device_getproperty:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_device_getproperty)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_device_getproperty", "unmapped");
return;
 }

p15 = (struct kgsl_device_getproperty *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_device_getproperty");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p15 , 0, sizeof(struct kgsl_device_getproperty));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p15->value), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_value");
xmlTextWriterWriteBase64(writer, (char *) (p15->value), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_value", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_device_waittimestamp:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_device_waittimestamp)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_device_waittimestamp", "unmapped");
return;
 }

p16 = (struct kgsl_device_waittimestamp *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_device_waittimestamp");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p16 , 0, sizeof(struct kgsl_device_waittimestamp));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_device_waittimestamp_ctxtid:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_device_waittimestamp_ctxtid)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_device_waittimestamp_ctxtid", "unmapped");
return;
 }

p17 = (struct kgsl_device_waittimestamp_ctxtid *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_device_waittimestamp_ctxtid");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p17 , 0, sizeof(struct kgsl_device_waittimestamp_ctxtid));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_ringbuffer_issueibcmds:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_ringbuffer_issueibcmds)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_ringbuffer_issueibcmds", "unmapped");
return;
 }

p18 = (struct kgsl_ringbuffer_issueibcmds *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_ringbuffer_issueibcmds");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p18 , 0, sizeof(struct kgsl_ringbuffer_issueibcmds));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p18->ibdesc_addr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_ibdesc_addr");
xmlTextWriterWriteBase64(writer, (char *) (p18->ibdesc_addr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_ibdesc_addr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_readtimestamp:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_readtimestamp)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp", "unmapped");
return;
 }

p19 = (struct kgsl_cmdstream_readtimestamp *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p19 , 0, sizeof(struct kgsl_cmdstream_readtimestamp));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_freememontimestamp:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_freememontimestamp)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp", "unmapped");
return;
 }

p20 = (struct kgsl_cmdstream_freememontimestamp *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p20 , 0, sizeof(struct kgsl_cmdstream_freememontimestamp));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p20->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p20->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_drawctxt_create:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_drawctxt_create)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_drawctxt_create", "unmapped");
return;
 }

p21 = (struct kgsl_drawctxt_create *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_drawctxt_create");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p21 , 0, sizeof(struct kgsl_drawctxt_create));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_map_user_mem:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_map_user_mem)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_map_user_mem", "unmapped");
return;
 }

p22 = (struct kgsl_map_user_mem *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_map_user_mem");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p22 , 0, sizeof(struct kgsl_map_user_mem));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p22->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p22->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p22->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p22->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_readtimestamp_ctxtid:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_readtimestamp_ctxtid)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp_ctxtid", "unmapped");
return;
 }

p23 = (struct kgsl_cmdstream_readtimestamp_ctxtid *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_readtimestamp_ctxtid");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p23 , 0, sizeof(struct kgsl_cmdstream_readtimestamp_ctxtid));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdstream_freememontimestamp_ctxtid:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdstream_freememontimestamp_ctxtid)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp_ctxtid", "unmapped");
return;
 }

p24 = (struct kgsl_cmdstream_freememontimestamp_ctxtid *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdstream_freememontimestamp_ctxtid");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p24 , 0, sizeof(struct kgsl_cmdstream_freememontimestamp_ctxtid));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p24->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p24->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_sharedmem_from_pmem:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_sharedmem_from_pmem)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_sharedmem_from_pmem", "unmapped");
return;
 }

p25 = (struct kgsl_sharedmem_from_pmem *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_sharedmem_from_pmem");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p25 , 0, sizeof(struct kgsl_sharedmem_from_pmem));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p25->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p25->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_sharedmem_free:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_sharedmem_free)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_sharedmem_free", "unmapped");
return;
 }

p26 = (struct kgsl_sharedmem_free *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_sharedmem_free");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p26 , 0, sizeof(struct kgsl_sharedmem_free));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p26->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p26->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cff_user_event:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cff_user_event)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cff_user_event", "unmapped");
return;
 }

p27 = (struct kgsl_cff_user_event *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cff_user_event");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p27 , 0, sizeof(struct kgsl_cff_user_event));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gmem_desc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gmem_desc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gmem_desc", "unmapped");
return;
 }

p28 = (struct kgsl_gmem_desc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gmem_desc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p28 , 0, sizeof(struct kgsl_gmem_desc));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_buffer_desc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_buffer_desc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_buffer_desc", "unmapped");
return;
 }

p29 = (struct kgsl_buffer_desc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_buffer_desc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p29 , 0, sizeof(struct kgsl_buffer_desc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p29->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p29->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p29->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p29->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_bind_gmem_shadow:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_bind_gmem_shadow)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_bind_gmem_shadow", "unmapped");
return;
 }

p30 = (struct kgsl_bind_gmem_shadow *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_bind_gmem_shadow");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p30 , 0, sizeof(struct kgsl_bind_gmem_shadow));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_sharedmem_from_vmalloc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_sharedmem_from_vmalloc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_sharedmem_from_vmalloc", "unmapped");
return;
 }

p31 = (struct kgsl_sharedmem_from_vmalloc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_sharedmem_from_vmalloc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p31 , 0, sizeof(struct kgsl_sharedmem_from_vmalloc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p31->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p31->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p31->hostptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_hostptr");
xmlTextWriterWriteBase64(writer, (char *) (p31->hostptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_hostptr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_drawctxt_set_bin_base_offset:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_drawctxt_set_bin_base_offset)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_drawctxt_set_bin_base_offset", "unmapped");
return;
 }

p32 = (struct kgsl_drawctxt_set_bin_base_offset *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_drawctxt_set_bin_base_offset");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p32 , 0, sizeof(struct kgsl_drawctxt_set_bin_base_offset));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cmdwindow_write:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cmdwindow_write)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cmdwindow_write", "unmapped");
return;
 }

p33 = (struct kgsl_cmdwindow_write *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cmdwindow_write");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p33 , 0, sizeof(struct kgsl_cmdwindow_write));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p33->addr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_addr");
xmlTextWriterWriteBase64(writer, (char *) (p33->addr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_addr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_cff_syncmem:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_cff_syncmem)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_cff_syncmem", "unmapped");
return;
 }

p34 = (struct kgsl_cff_syncmem *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_cff_syncmem");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p34 , 0, sizeof(struct kgsl_cff_syncmem));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p34->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p34->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_timestamp_event:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_timestamp_event)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_timestamp_event", "unmapped");
return;
 }

p35 = (struct kgsl_timestamp_event *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_timestamp_event");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p35 , 0, sizeof(struct kgsl_timestamp_event));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p35->priv), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_priv");
xmlTextWriterWriteBase64(writer, (char *) (p35->priv), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_priv", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_timestamp_event_genlock:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_timestamp_event_genlock)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_timestamp_event_genlock", "unmapped");
return;
 }

p36 = (struct kgsl_timestamp_event_genlock *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_timestamp_event_genlock");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p36 , 0, sizeof(struct kgsl_timestamp_event_genlock));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_timestamp_event_fence:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_timestamp_event_fence)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_timestamp_event_fence", "unmapped");
return;
 }

p37 = (struct kgsl_timestamp_event_fence *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_timestamp_event_fence");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p37 , 0, sizeof(struct kgsl_timestamp_event_fence));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_alloc_id:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_alloc_id)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_alloc_id", "unmapped");
return;
 }

p38 = (struct kgsl_gpumem_alloc_id *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_alloc_id");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p38 , 0, sizeof(struct kgsl_gpumem_alloc_id));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p38->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p38->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_free_id:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_free_id)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_free_id", "unmapped");
return;
 }

p39 = (struct kgsl_gpumem_free_id *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_free_id");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p39 , 0, sizeof(struct kgsl_gpumem_free_id));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_get_info:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_get_info)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_get_info", "unmapped");
return;
 }

p40 = (struct kgsl_gpumem_get_info *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_get_info");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p40 , 0, sizeof(struct kgsl_gpumem_get_info));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p40->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p40->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p40->useraddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_useraddr");
xmlTextWriterWriteBase64(writer, (char *) (p40->useraddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_useraddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_sync_cache:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_sync_cache)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_sync_cache", "unmapped");
return;
 }

p41 = (struct kgsl_gpumem_sync_cache *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_sync_cache");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p41 , 0, sizeof(struct kgsl_gpumem_sync_cache));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p41->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p41->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_get:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_get)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_get", "unmapped");
return;
 }

p42 = (struct kgsl_perfcounter_get *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_get");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p42 , 0, sizeof(struct kgsl_perfcounter_get));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_put:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_put)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_put", "unmapped");
return;
 }

p43 = (struct kgsl_perfcounter_put *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_put");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p43 , 0, sizeof(struct kgsl_perfcounter_put));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_query:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_query)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_query", "unmapped");
return;
 }

p44 = (struct kgsl_perfcounter_query *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_query");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p44 , 0, sizeof(struct kgsl_perfcounter_query));
xmlTextWriterEndElement(writer);

// pointer to primitive
if(write(nullfd, (void *)(p44->countables), 4) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_countables");
xmlTextWriterWriteBase64(writer, (char *) (p44->countables), 0, 4);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_countables", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_read_group:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_read_group)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_read_group", "unmapped");
return;
 }

p45 = (struct kgsl_perfcounter_read_group *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_read_group");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p45 , 0, sizeof(struct kgsl_perfcounter_read_group));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_perfcounter_read:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_perfcounter_read)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_perfcounter_read", "unmapped");
return;
 }

p46 = (struct kgsl_perfcounter_read *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_perfcounter_read");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p46 , 0, sizeof(struct kgsl_perfcounter_read));
xmlTextWriterEndElement(writer);

// Pointer to struct kgsl_perfcounter_read_group
struct_recursive_analyze((void *)(p46->reads), TRUE, STRUCT_kgsl_perfcounter_read_group, 0, writer);
xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_drawctxt_destroy:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_drawctxt_destroy)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_drawctxt_destroy", "unmapped");
return;
 }

p47 = (struct kgsl_drawctxt_destroy *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_drawctxt_destroy");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p47 , 0, sizeof(struct kgsl_drawctxt_destroy));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_kgsl_gpumem_alloc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct kgsl_gpumem_alloc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_kgsl_gpumem_alloc", "unmapped");
return;
 }

p48 = (struct kgsl_gpumem_alloc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_kgsl_gpumem_alloc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p48 , 0, sizeof(struct kgsl_gpumem_alloc));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p48->gpuaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_gpuaddr");
xmlTextWriterWriteBase64(writer, (char *) (p48->gpuaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_gpuaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_mc_ioctl_init:
if(write(nullfd, (void *) arg_ptr, sizeof(struct mc_ioctl_init)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_mc_ioctl_init", "unmapped");
return;
 }

p49 = (struct mc_ioctl_init *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_mc_ioctl_init");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p49 , 0, sizeof(struct mc_ioctl_init));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_mc_ioctl_info:
if(write(nullfd, (void *) arg_ptr, sizeof(struct mc_ioctl_info)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_mc_ioctl_info", "unmapped");
return;
 }

p50 = (struct mc_ioctl_info *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_mc_ioctl_info");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p50 , 0, sizeof(struct mc_ioctl_info));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_mc_ioctl_map:
if(write(nullfd, (void *) arg_ptr, sizeof(struct mc_ioctl_map)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_mc_ioctl_map", "unmapped");
return;
 }

p51 = (struct mc_ioctl_map *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_mc_ioctl_map");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p51 , 0, sizeof(struct mc_ioctl_map));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p51->addr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_addr");
xmlTextWriterWriteBase64(writer, (char *) (p51->addr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_addr", "unmapped");
// void pointer
if(write(nullfd, (void *)(p51->phys_addr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_phys_addr");
xmlTextWriterWriteBase64(writer, (char *) (p51->phys_addr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_phys_addr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_mc_ioctl_reg_wsm:
if(write(nullfd, (void *) arg_ptr, sizeof(struct mc_ioctl_reg_wsm)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_mc_ioctl_reg_wsm", "unmapped");
return;
 }

p52 = (struct mc_ioctl_reg_wsm *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_mc_ioctl_reg_wsm");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p52 , 0, sizeof(struct mc_ioctl_reg_wsm));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p52->table_phys), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_table_phys");
xmlTextWriterWriteBase64(writer, (char *) (p52->table_phys), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_table_phys", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_mc_ioctl_execute:
if(write(nullfd, (void *) arg_ptr, sizeof(struct mc_ioctl_execute)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_mc_ioctl_execute", "unmapped");
return;
 }

p53 = (struct mc_ioctl_execute *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_mc_ioctl_execute");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p53 , 0, sizeof(struct mc_ioctl_execute));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p53->phys_start_addr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_phys_start_addr");
xmlTextWriterWriteBase64(writer, (char *) (p53->phys_start_addr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_phys_start_addr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_mc_ioctl_resolv_cont_wsm:
if(write(nullfd, (void *) arg_ptr, sizeof(struct mc_ioctl_resolv_cont_wsm)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_mc_ioctl_resolv_cont_wsm", "unmapped");
return;
 }

p54 = (struct mc_ioctl_resolv_cont_wsm *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_mc_ioctl_resolv_cont_wsm");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p54 , 0, sizeof(struct mc_ioctl_resolv_cont_wsm));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p54->phys), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_phys");
xmlTextWriterWriteBase64(writer, (char *) (p54->phys), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_phys", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_mc_ioctl_resolv_wsm:
if(write(nullfd, (void *) arg_ptr, sizeof(struct mc_ioctl_resolv_wsm)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_mc_ioctl_resolv_wsm", "unmapped");
return;
 }

p55 = (struct mc_ioctl_resolv_wsm *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_mc_ioctl_resolv_wsm");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p55 , 0, sizeof(struct mc_ioctl_resolv_wsm));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p55->phys), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_phys");
xmlTextWriterWriteBase64(writer, (char *) (p55->phys), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_phys", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_msm_jpeg_ctrl_cmd:
if(write(nullfd, (void *) arg_ptr, sizeof(struct msm_jpeg_ctrl_cmd)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_msm_jpeg_ctrl_cmd", "unmapped");
return;
 }

p56 = (struct msm_jpeg_ctrl_cmd *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_msm_jpeg_ctrl_cmd");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p56 , 0, sizeof(struct msm_jpeg_ctrl_cmd));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p56->value), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_value");
xmlTextWriterWriteBase64(writer, (char *) (p56->value), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_value", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_msm_jpeg_buf:
if(write(nullfd, (void *) arg_ptr, sizeof(struct msm_jpeg_buf)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_msm_jpeg_buf", "unmapped");
return;
 }

p57 = (struct msm_jpeg_buf *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_msm_jpeg_buf");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p57 , 0, sizeof(struct msm_jpeg_buf));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p57->vaddr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_vaddr");
xmlTextWriterWriteBase64(writer, (char *) (p57->vaddr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_vaddr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_msm_jpeg_hw_cmd:
if(write(nullfd, (void *) arg_ptr, sizeof(struct msm_jpeg_hw_cmd)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_msm_jpeg_hw_cmd", "unmapped");
return;
 }

p58 = (struct msm_jpeg_hw_cmd *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_msm_jpeg_hw_cmd");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p58 , 0, sizeof(struct msm_jpeg_hw_cmd));
xmlTextWriterEndElement(writer);

// pointer to primitive
if(write(nullfd, (void *)(p58->pdata), 4) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_pdata");
xmlTextWriterWriteBase64(writer, (char *) (p58->pdata), 0, 4);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_pdata", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_msm_jpeg_hw_cmds:
if(write(nullfd, (void *) arg_ptr, sizeof(struct msm_jpeg_hw_cmds)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_msm_jpeg_hw_cmds", "unmapped");
return;
 }

p59 = (struct msm_jpeg_hw_cmds *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_msm_jpeg_hw_cmds");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p59 , 0, sizeof(struct msm_jpeg_hw_cmds));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_timespec:
if(write(nullfd, (void *) arg_ptr, sizeof(struct timespec)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_timespec", "unmapped");
return;
 }

p60 = (struct timespec *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_timespec");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p60 , 0, sizeof(struct timespec));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_capability:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_capability)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_capability", "unmapped");
return;
 }

p61 = (struct v4l2_capability *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_capability");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p61 , 0, sizeof(struct v4l2_capability));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_fmtdesc:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_fmtdesc)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_fmtdesc", "unmapped");
return;
 }

p62 = (struct v4l2_fmtdesc *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_fmtdesc");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p62 , 0, sizeof(struct v4l2_fmtdesc));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_rect:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_rect)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_rect", "unmapped");
return;
 }

p63 = (struct v4l2_rect *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_rect");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p63 , 0, sizeof(struct v4l2_rect));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_clip:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_clip)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_clip", "unmapped");
return;
 }

p64 = (struct v4l2_clip *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_clip");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p64 , 0, sizeof(struct v4l2_clip));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p64->next), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_next");
xmlTextWriterWriteBase64(writer, (char *) (p64->next), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_next", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_window:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_window)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_window", "unmapped");
return;
 }

p65 = (struct v4l2_window *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_window");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p65 , 0, sizeof(struct v4l2_window));
xmlTextWriterEndElement(writer);

// Pointer to struct v4l2_clip
struct_recursive_analyze((void *)(p65->clips), TRUE, STRUCT_v4l2_clip, 0, writer);
// void pointer
if(write(nullfd, (void *)(p65->bitmap), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_bitmap");
xmlTextWriterWriteBase64(writer, (char *) (p65->bitmap), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_bitmap", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_format:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_format)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_format", "unmapped");
return;
 }

p66 = (struct v4l2_format *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_format");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p66 , 0, sizeof(struct v4l2_format));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_requestbuffers:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_requestbuffers)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_requestbuffers", "unmapped");
return;
 }

p67 = (struct v4l2_requestbuffers *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_requestbuffers");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p67 , 0, sizeof(struct v4l2_requestbuffers));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_timecode:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_timecode)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_timecode", "unmapped");
return;
 }

p68 = (struct v4l2_timecode *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_timecode");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p68 , 0, sizeof(struct v4l2_timecode));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_plane:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_plane)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_plane", "unmapped");
return;
 }

p69 = (struct v4l2_plane *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_plane");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p69 , 0, sizeof(struct v4l2_plane));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p69->userptr), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_userptr");
xmlTextWriterWriteBase64(writer, (char *) (p69->userptr), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_userptr", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_timeval:
if(write(nullfd, (void *) arg_ptr, sizeof(struct timeval)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_timeval", "unmapped");
return;
 }

p70 = (struct timeval *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_timeval");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p70 , 0, sizeof(struct timeval));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_buffer:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_buffer)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_buffer", "unmapped");
return;
 }

p71 = (struct v4l2_buffer *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_buffer");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p71 , 0, sizeof(struct v4l2_buffer));
xmlTextWriterEndElement(writer);

// Pointer to struct v4l2_plane
struct_recursive_analyze((void *)(p71->planes), TRUE, STRUCT_v4l2_plane, 0, writer);
xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_plane_pix_format:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_plane_pix_format)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_plane_pix_format", "unmapped");
return;
 }

p72 = (struct v4l2_plane_pix_format *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_plane_pix_format");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p72 , 0, sizeof(struct v4l2_plane_pix_format));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_pix_format_mplane:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_pix_format_mplane)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_pix_format_mplane", "unmapped");
return;
 }

p73 = (struct v4l2_pix_format_mplane *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_pix_format_mplane");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p73 , 0, sizeof(struct v4l2_pix_format_mplane));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_pix_format:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_pix_format)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_pix_format", "unmapped");
return;
 }

p74 = (struct v4l2_pix_format *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_pix_format");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p74 , 0, sizeof(struct v4l2_pix_format));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_framebuffer:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_framebuffer)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_framebuffer", "unmapped");
return;
 }

p75 = (struct v4l2_framebuffer *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_framebuffer");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p75 , 0, sizeof(struct v4l2_framebuffer));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p75->base), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_base");
xmlTextWriterWriteBase64(writer, (char *) (p75->base), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_base", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_streamparm:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_streamparm)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_streamparm", "unmapped");
return;
 }

p76 = (struct v4l2_streamparm *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_streamparm");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p76 , 0, sizeof(struct v4l2_streamparm));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_fract:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_fract)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_fract", "unmapped");
return;
 }

p77 = (struct v4l2_fract *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_fract");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p77 , 0, sizeof(struct v4l2_fract));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_standard:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_standard)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_standard", "unmapped");
return;
 }

p78 = (struct v4l2_standard *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_standard");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p78 , 0, sizeof(struct v4l2_standard));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_input:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_input)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_input", "unmapped");
return;
 }

p79 = (struct v4l2_input *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_input");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p79 , 0, sizeof(struct v4l2_input));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_control:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_control)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_control", "unmapped");
return;
 }

p80 = (struct v4l2_control *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_control");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p80 , 0, sizeof(struct v4l2_control));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_tuner:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_tuner)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_tuner", "unmapped");
return;
 }

p81 = (struct v4l2_tuner *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_tuner");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p81 , 0, sizeof(struct v4l2_tuner));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_modulator:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_modulator)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_modulator", "unmapped");
return;
 }

p82 = (struct v4l2_modulator *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_modulator");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p82 , 0, sizeof(struct v4l2_modulator));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_audio:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_audio)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_audio", "unmapped");
return;
 }

p83 = (struct v4l2_audio *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_audio");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p83 , 0, sizeof(struct v4l2_audio));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_queryctrl:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_queryctrl)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_queryctrl", "unmapped");
return;
 }

p84 = (struct v4l2_queryctrl *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_queryctrl");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p84 , 0, sizeof(struct v4l2_queryctrl));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_querymenu:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_querymenu)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_querymenu", "unmapped");
return;
 }

p85 = (struct v4l2_querymenu *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_querymenu");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p85 , 0, sizeof(struct v4l2_querymenu));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_outputparm:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_outputparm)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_outputparm", "unmapped");
return;
 }

p86 = (struct v4l2_outputparm *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_outputparm");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p86 , 0, sizeof(struct v4l2_outputparm));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_audioout:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_audioout)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_audioout", "unmapped");
return;
 }

p87 = (struct v4l2_audioout *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_audioout");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p87 , 0, sizeof(struct v4l2_audioout));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_frequency:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_frequency)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_frequency", "unmapped");
return;
 }

p88 = (struct v4l2_frequency *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_frequency");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p88 , 0, sizeof(struct v4l2_frequency));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_cropcap:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_cropcap)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_cropcap", "unmapped");
return;
 }

p89 = (struct v4l2_cropcap *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_cropcap");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p89 , 0, sizeof(struct v4l2_cropcap));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_crop:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_crop)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_crop", "unmapped");
return;
 }

p90 = (struct v4l2_crop *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_crop");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p90 , 0, sizeof(struct v4l2_crop));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_jpegcompression:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_jpegcompression)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_jpegcompression", "unmapped");
return;
 }

p91 = (struct v4l2_jpegcompression *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_jpegcompression");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p91 , 0, sizeof(struct v4l2_jpegcompression));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_sliced_vbi_cap:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_sliced_vbi_cap)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_sliced_vbi_cap", "unmapped");
return;
 }

p92 = (struct v4l2_sliced_vbi_cap *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_sliced_vbi_cap");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p92 , 0, sizeof(struct v4l2_sliced_vbi_cap));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_ext_controls:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_ext_controls)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_ext_controls", "unmapped");
return;
 }

p93 = (struct v4l2_ext_controls *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_ext_controls");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p93 , 0, sizeof(struct v4l2_ext_controls));
xmlTextWriterEndElement(writer);

// void pointer
if(write(nullfd, (void *)(p93->controls), 128) >= 0) {
xmlTextWriterStartElement(writer, "POINTER_controls");
xmlTextWriterWriteBase64(writer, (char *) (p93->controls), 0, 128);
xmlTextWriterEndElement(writer);
}
else
xmlTextWriterWriteElement(writer, "POINTER_controls", "unmapped");
xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_frmsize_stepwise:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_frmsize_stepwise)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_frmsize_stepwise", "unmapped");
return;
 }

p94 = (struct v4l2_frmsize_stepwise *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_frmsize_stepwise");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p94 , 0, sizeof(struct v4l2_frmsize_stepwise));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_frmsizeenum:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_frmsizeenum)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_frmsizeenum", "unmapped");
return;
 }

p95 = (struct v4l2_frmsizeenum *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_frmsizeenum");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p95 , 0, sizeof(struct v4l2_frmsizeenum));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_frmival_stepwise:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_frmival_stepwise)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_frmival_stepwise", "unmapped");
return;
 }

p96 = (struct v4l2_frmival_stepwise *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_frmival_stepwise");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p96 , 0, sizeof(struct v4l2_frmival_stepwise));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_frmivalenum:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_frmivalenum)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_frmivalenum", "unmapped");
return;
 }

p97 = (struct v4l2_frmivalenum *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_frmivalenum");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p97 , 0, sizeof(struct v4l2_frmivalenum));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_enc_idx_entry:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_enc_idx_entry)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_enc_idx_entry", "unmapped");
return;
 }

p98 = (struct v4l2_enc_idx_entry *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_enc_idx_entry");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p98 , 0, sizeof(struct v4l2_enc_idx_entry));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_enc_idx:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_enc_idx)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_enc_idx", "unmapped");
return;
 }

p99 = (struct v4l2_enc_idx *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_enc_idx");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p99 , 0, sizeof(struct v4l2_enc_idx));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_encoder_cmd:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_encoder_cmd)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_encoder_cmd", "unmapped");
return;
 }

p100 = (struct v4l2_encoder_cmd *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_encoder_cmd");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p100 , 0, sizeof(struct v4l2_encoder_cmd));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_dbg_match:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_dbg_match)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_dbg_match", "unmapped");
return;
 }

p101 = (struct v4l2_dbg_match *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_dbg_match");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p101 , 0, sizeof(struct v4l2_dbg_match));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_dbg_register:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_dbg_register)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_dbg_register", "unmapped");
return;
 }

p102 = (struct v4l2_dbg_register *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_dbg_register");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p102 , 0, sizeof(struct v4l2_dbg_register));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_dbg_chip_ident:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_dbg_chip_ident)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_dbg_chip_ident", "unmapped");
return;
 }

p103 = (struct v4l2_dbg_chip_ident *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_dbg_chip_ident");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p103 , 0, sizeof(struct v4l2_dbg_chip_ident));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_hw_freq_seek:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_hw_freq_seek)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_hw_freq_seek", "unmapped");
return;
 }

p104 = (struct v4l2_hw_freq_seek *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_hw_freq_seek");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p104 , 0, sizeof(struct v4l2_hw_freq_seek));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_dv_enum_preset:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_dv_enum_preset)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_dv_enum_preset", "unmapped");
return;
 }

p105 = (struct v4l2_dv_enum_preset *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_dv_enum_preset");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p105 , 0, sizeof(struct v4l2_dv_enum_preset));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_dv_preset:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_dv_preset)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_dv_preset", "unmapped");
return;
 }

p106 = (struct v4l2_dv_preset *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_dv_preset");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p106 , 0, sizeof(struct v4l2_dv_preset));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_dv_timings:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_dv_timings)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_dv_timings", "unmapped");
return;
 }

p107 = (struct v4l2_dv_timings *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_dv_timings");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p107 , 0, sizeof(struct v4l2_dv_timings));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_event:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_event)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_event", "unmapped");
return;
 }

p108 = (struct v4l2_event *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_event");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p108 , 0, sizeof(struct v4l2_event));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_event_subscription:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_event_subscription)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_event_subscription", "unmapped");
return;
 }

p109 = (struct v4l2_event_subscription *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_event_subscription");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p109 , 0, sizeof(struct v4l2_event_subscription));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_create_buffers:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_create_buffers)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_create_buffers", "unmapped");
return;
 }

p110 = (struct v4l2_create_buffers *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_create_buffers");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p110 , 0, sizeof(struct v4l2_create_buffers));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_selection:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_selection)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_selection", "unmapped");
return;
 }

p111 = (struct v4l2_selection *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_selection");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p111 , 0, sizeof(struct v4l2_selection));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_decoder_cmd:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_decoder_cmd)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_decoder_cmd", "unmapped");
return;
 }

p112 = (struct v4l2_decoder_cmd *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_decoder_cmd");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p112 , 0, sizeof(struct v4l2_decoder_cmd));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;


case STRUCT_v4l2_output:
if(write(nullfd, (void *) arg_ptr, sizeof(struct v4l2_output)) < 0) {
xmlTextWriterWriteElement(writer, "STRUCT_v4l2_output", "unmapped");
return;
 }

p113 = (struct v4l2_output *) arg_ptr;
xmlTextWriterStartElement(writer, "STRUCT_v4l2_output");
xmlTextWriterStartElement(writer, "CONTENT_DUMP");
xmlTextWriterWriteBase64(writer, (char *) p113 , 0, sizeof(struct v4l2_output));
xmlTextWriterEndElement(writer);

xmlTextWriterEndElement(writer);

return;



}
}
}
