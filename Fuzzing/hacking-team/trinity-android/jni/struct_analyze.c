/***** Automatically generated by gen_recursive.c *********/

#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <libxml/xmlwriter.h>
#include <libxml/encoding.h>
#include <sys/timex.h>
#include <sys/times.h>
#include <sched.h>
#include <linux/kexec.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/vfs.h>
#include <sys/syscall.h>
#include <linux/aio_abi.h>
#include <unistd.h>
#include <utime.h>
#include <dirent.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <poll.h>
#include <sys/epoll.h>
#include <sys/utsname.h>
#include <linux/utsname.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <linux/shm.h>
#include <linux/futex.h>
#include <linux/fs.h>
#include <sys/sem.h>
#include <linux/mqueue.h>
#include <linux/sysctl.h>
#include <linux/perf_event.h>


#include "struct_analyze.h"
#include "syscall.h"

int nullfd = 0;

struct file_handle {
  unsigned int  handle_bytes;   /* Size of f_handle [in, out] */
  int           handle_type;    /* Handle type [out] */
  unsigned char f_handle[0];    /* File identifier (sized by
				   caller) [out] */
};

struct mmap_arg_struct {
  unsigned long addr;
  unsigned long len;
  unsigned long prot;
  unsigned long flags;
  unsigned long fd;
  unsigned long offset;
}; 

struct linux_dirent64 {
  u64             d_ino;
  unsigned long             d_off;
  unsigned short  d_reclen;
  unsigned char   d_type;
  char            d_name[0];
};

struct linux_dirent {
  u32 d_ino;
  unsigned long d_off;
  unsigned short len;
  char d_name[256];
};


struct sel_arg_struct {
  unsigned long n;
  fd_set __user *inp, *outp, *exp;
  struct timeval __user *tvp;
};


struct getcpu_cache {
  unsigned long blob[128 / sizeof(long)];
};



void struct_recursive_analyze(void *arg_ptr, enum struct_argtype struct_argtype, xmlTextWriterPtr writer) {

  if(arg_ptr == NULL)
    return;
  if(nullfd == 0)
    nullfd = open("/dev/random", O_WRONLY);

  switch(struct_argtype) {
    struct timeval timeval_s;
    struct timeval *timeval_p;

    struct timezone timezone_s;
    struct timezone *timezone_p;

    struct timex timex_s;
    struct timex *timex_p;

    struct tms tms_s;
    struct tms *tms_p;

    struct timespec timespec_s;
    struct timespec *timespec_p;

    struct itimerval itimerval_s;
    struct itimerval *itimerval_p;

    struct sigevent sigevent_s;
    struct sigevent *sigevent_p;

    struct itimerspec itimerspec_s;
    struct itimerspec *itimerspec_p;

    struct sched_param sched_param_s;
    struct sched_param *sched_param_p;

    struct kexec_segment kexec_segment_s;
    struct kexec_segment *kexec_segment_p;

    struct rusage rusage_s;
    struct rusage *rusage_p;

    struct siginfo siginfo_s;
    struct siginfo *siginfo_p;

    struct statfs statfs_s;
    struct statfs *statfs_p;

    struct statfs64 statfs64_s;
    struct statfs64 *statfs64_p;

    struct stat stat_s;
    struct stat *stat_p;

    struct stat64 stat64_s;
    struct stat64 *stat64_p;

    struct io_event io_event_s;
    struct io_event *io_event_p;

    struct iocb iocb_s;
    struct iocb *iocb_p;

    struct utimbuf utimbuf_s;
    struct utimbuf *utimbuf_p;

    struct iovec iovec_s;
    struct iovec *iovec_p;

    struct linux_dirent linux_dirent_s;
    struct linux_dirent *linux_dirent_p;

    struct linux_dirent64 linux_dirent64_s;
    struct linux_dirent64 *linux_dirent64_p;

    struct sockaddr sockaddr_s;
    struct sockaddr *sockaddr_p;

    struct msghdr msghdr_s;
    struct msghdr *msghdr_p;

    struct mmsghdr mmsghdr_s;
    struct mmsghdr *mmsghdr_p;

    struct pollfd pollfd_s;
    struct pollfd *pollfd_p;

    struct sel_arg_struct sel_arg_struct_s;
    struct sel_arg_struct *sel_arg_struct_p;

    struct epoll_event epoll_event_s;
    struct epoll_event *epoll_event_p;

    struct new_utsname new_utsname_s;
    struct new_utsname *new_utsname_p;

    struct rlimit rlimit_s;
    struct rlimit *rlimit_p;

    struct rlimit64 rlimit64_s;
    struct rlimit64 *rlimit64_p;

    struct msgbuf msgbuf_s;
    struct msgbuf *msgbuf_p;

    struct msqid_ds msqid_ds_s;
    struct msqid_ds *msqid_ds_p;

    struct sembuf sembuf_s;
    struct sembuf *sembuf_p;

    struct shmid_ds shmid_ds_s;
    struct shmid_ds *shmid_ds_p;

    struct mq_attr mq_attr_s;
    struct mq_attr *mq_attr_p;

    struct __sysctl_args __sysctl_args_s;
    struct __sysctl_args *__sysctl_args_p;

    struct robust_list_head robust_list_head_s;
    struct robust_list_head *robust_list_head_p;

    struct getcpu_cache getcpu_cache_s;
    struct getcpu_cache *getcpu_cache_p;

    struct perf_event_attr perf_event_attr_s;
    struct perf_event_attr *perf_event_attr_p;

    struct mmap_arg_struct mmap_arg_struct_s;
    struct mmap_arg_struct *mmap_arg_struct_p;

    struct file_handle file_handle_s;
    struct file_handle *file_handle_p;

  case STRUCT_ARG_timeval:
    if(write(nullfd, (void *) arg_ptr, sizeof(timeval_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_timeval", "unmapped");
      return;
    }

    timeval_p = (struct timeval *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_timeval");
    xmlTextWriterWriteBase64(writer, (char *) timeval_p, 0, sizeof(timeval_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_timezone:
    if(write(nullfd, (void *) arg_ptr, sizeof(timezone_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_timezone", "unmapped");
      return;
    }

    timezone_p = (struct timezone *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_timezone");
    xmlTextWriterWriteBase64(writer, (char *) timezone_p, 0, sizeof(timezone_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_timex:
    if(write(nullfd, (void *) arg_ptr, sizeof(timex_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_timex", "unmapped");
      return;
    }

    timex_p = (struct timex *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_timex");
    xmlTextWriterWriteBase64(writer, (char *) timex_p, 0, sizeof(timex_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_tms:
    if(write(nullfd, (void *) arg_ptr, sizeof(tms_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_tms", "unmapped");
      return;
    }

    tms_p = (struct tms *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_tms");
    xmlTextWriterWriteBase64(writer, (char *) tms_p, 0, sizeof(tms_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_timespec:
    if(write(nullfd, (void *) arg_ptr, sizeof(timespec_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_timespec", "unmapped");
      return;
    }

    timespec_p = (struct timespec *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_timespec");
    xmlTextWriterWriteBase64(writer, (char *) timespec_p, 0, sizeof(timespec_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_itimerval:
    if(write(nullfd, (void *) arg_ptr, sizeof(itimerval_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_itimerval", "unmapped");
      return;
    }

    itimerval_p = (struct itimerval *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_itimerval");
    xmlTextWriterWriteBase64(writer, (char *) itimerval_p, 0, sizeof(itimerval_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_sigevent:
    if(write(nullfd, (void *) arg_ptr, sizeof(sigevent_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_sigevent", "unmapped");
      return;
    }

    sigevent_p = (struct sigevent *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_sigevent");
    xmlTextWriterWriteBase64(writer, (char *) sigevent_p, 0, sizeof(sigevent_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_itimerspec:
    if(write(nullfd, (void *) arg_ptr, sizeof(itimerspec_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_itimerspec", "unmapped");
      return;
    }

    itimerspec_p = (struct itimerspec *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_itimerspec");
    xmlTextWriterWriteBase64(writer, (char *) itimerspec_p, 0, sizeof(itimerspec_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_sched_param:
    if(write(nullfd, (void *) arg_ptr, sizeof(sched_param_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_sched_param", "unmapped");
      return;
    }

    sched_param_p = (struct sched_param *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_sched_param");
    xmlTextWriterWriteBase64(writer, (char *) sched_param_p, 0, sizeof(sched_param_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_kexec_segment:
    if(write(nullfd, (void *) arg_ptr, sizeof(kexec_segment_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_kexec_segment", "unmapped");
      return;
    }

    kexec_segment_p = (struct kexec_segment *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_kexec_segment");
    xmlTextWriterWriteBase64(writer, (char *) kexec_segment_p, 0, sizeof(kexec_segment_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_rusage:
    if(write(nullfd, (void *) arg_ptr, sizeof(rusage_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_rusage", "unmapped");
      return;
    }

    rusage_p = (struct rusage *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_rusage");
    xmlTextWriterWriteBase64(writer, (char *) rusage_p, 0, sizeof(rusage_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_siginfo:
    if(write(nullfd, (void *) arg_ptr, sizeof(siginfo_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_siginfo", "unmapped");
      return;
    }

    siginfo_p = (struct siginfo *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_siginfo");
    xmlTextWriterWriteBase64(writer, (char *) siginfo_p, 0, sizeof(siginfo_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_statfs:
    if(write(nullfd, (void *) arg_ptr, sizeof(statfs_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_statfs", "unmapped");
      return;
    }

    statfs_p = (struct statfs *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_statfs");
    xmlTextWriterWriteBase64(writer, (char *) statfs_p, 0, sizeof(statfs_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_statfs64:
    if(write(nullfd, (void *) arg_ptr, sizeof(statfs64_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_statfs64", "unmapped");
      return;
    }

    statfs64_p = (struct statfs64 *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_statfs64");
    xmlTextWriterWriteBase64(writer, (char *) statfs64_p, 0, sizeof(statfs64_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_stat:
    if(write(nullfd, (void *) arg_ptr, sizeof(stat_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_stat", "unmapped");
      return;
    }

    stat_p = (struct stat *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_stat");
    xmlTextWriterWriteBase64(writer, (char *) stat_p, 0, sizeof(stat_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_stat64:
    if(write(nullfd, (void *) arg_ptr, sizeof(stat64_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_stat64", "unmapped");
      return;
    }

    stat64_p = (struct stat64 *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_stat64");
    xmlTextWriterWriteBase64(writer, (char *) stat64_p, 0, sizeof(stat64_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_io_event:
    if(write(nullfd, (void *) arg_ptr, sizeof(io_event_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_io_event", "unmapped");
      return;
    }

    io_event_p = (struct io_event *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_io_event");
    xmlTextWriterWriteBase64(writer, (char *) io_event_p, 0, sizeof(io_event_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_iocb:
    if(write(nullfd, (void *) arg_ptr, sizeof(iocb_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_iocb", "unmapped");
      return;
    }

    iocb_p = (struct iocb *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_iocb");
    xmlTextWriterWriteBase64(writer, (char *) iocb_p, 0, sizeof(iocb_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_utimbuf:
    if(write(nullfd, (void *) arg_ptr, sizeof(utimbuf_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_utimbuf", "unmapped");
      return;
    }

    utimbuf_p = (struct utimbuf *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_utimbuf");
    xmlTextWriterWriteBase64(writer, (char *) utimbuf_p, 0, sizeof(utimbuf_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_iovec:
    if(write(nullfd, (void *) arg_ptr, sizeof(iovec_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_iovec", "unmapped");
      return;
    }

    iovec_p = (struct iovec *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_iovec");
    xmlTextWriterWriteBase64(writer, (char *) iovec_p, 0, sizeof(iovec_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_linux_dirent:
    if(write(nullfd, (void *) arg_ptr, sizeof(linux_dirent_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_linux_dirent", "unmapped");
      return;
    }

    linux_dirent_p = (struct linux_dirent *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_linux_dirent");
    xmlTextWriterWriteBase64(writer, (char *) linux_dirent_p, 0, sizeof(linux_dirent_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_linux_dirent64:
    if(write(nullfd, (void *) arg_ptr, sizeof(linux_dirent64_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_linux_dirent64", "unmapped");
      return;
    }

    linux_dirent64_p = (struct linux_dirent64 *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_linux_dirent64");
    xmlTextWriterWriteBase64(writer, (char *) linux_dirent64_p, 0, sizeof(linux_dirent64_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_sockaddr:
    if(write(nullfd, (void *) arg_ptr, sizeof(sockaddr_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_sockaddr", "unmapped");
      return;
    }

    sockaddr_p = (struct sockaddr *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_sockaddr");
    xmlTextWriterWriteBase64(writer, (char *) sockaddr_p, 0, sizeof(sockaddr_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_msghdr:
    if(write(nullfd, (void *) arg_ptr, sizeof(msghdr_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_msghdr", "unmapped");
      return;
    }

    msghdr_p = (struct msghdr *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_msghdr");
    xmlTextWriterWriteBase64(writer, (char *) msghdr_p, 0, sizeof(msghdr_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_mmsghdr:
    if(write(nullfd, (void *) arg_ptr, sizeof(mmsghdr_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_mmsghdr", "unmapped");
      return;
    }

    mmsghdr_p = (struct mmsghdr *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_mmsghdr");
    xmlTextWriterWriteBase64(writer, (char *) mmsghdr_p, 0, sizeof(mmsghdr_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_pollfd:
    if(write(nullfd, (void *) arg_ptr, sizeof(pollfd_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_pollfd", "unmapped");
      return;
    }

    pollfd_p = (struct pollfd *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_pollfd");
    xmlTextWriterWriteBase64(writer, (char *) pollfd_p, 0, sizeof(pollfd_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_sel_arg_struct:
    if(write(nullfd, (void *) arg_ptr, sizeof(sel_arg_struct_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_sel_arg_struct", "unmapped");
      return;
    }

    sel_arg_struct_p = (struct sel_arg_struct *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_sel_arg_struct");
    xmlTextWriterWriteBase64(writer, (char *) sel_arg_struct_p, 0, sizeof(sel_arg_struct_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_epoll_event:
    if(write(nullfd, (void *) arg_ptr, sizeof(epoll_event_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_epoll_event", "unmapped");
      return;
    }

    epoll_event_p = (struct epoll_event *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_epoll_event");
    xmlTextWriterWriteBase64(writer, (char *) epoll_event_p, 0, sizeof(epoll_event_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_new_utsname:
    if(write(nullfd, (void *) arg_ptr, sizeof(new_utsname_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_new_utsname", "unmapped");
      return;
    }

    new_utsname_p = (struct new_utsname *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_new_utsname");
    xmlTextWriterWriteBase64(writer, (char *) new_utsname_p, 0, sizeof(new_utsname_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_rlimit:
    if(write(nullfd, (void *) arg_ptr, sizeof(rlimit_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_rlimit", "unmapped");
      return;
    }

    rlimit_p = (struct rlimit *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_rlimit");
    xmlTextWriterWriteBase64(writer, (char *) rlimit_p, 0, sizeof(rlimit_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_rlimit64:
    if(write(nullfd, (void *) arg_ptr, sizeof(rlimit64_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_rlimit64", "unmapped");
      return;
    }

    rlimit64_p = (struct rlimit64 *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_rlimit64");
    xmlTextWriterWriteBase64(writer, (char *) rlimit64_p, 0, sizeof(rlimit64_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_msgbuf:
    if(write(nullfd, (void *) arg_ptr, sizeof(msgbuf_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_msgbuf", "unmapped");
      return;
    }

    msgbuf_p = (struct msgbuf *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_msgbuf");
    xmlTextWriterWriteBase64(writer, (char *) msgbuf_p, 0, sizeof(msgbuf_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_msqid_ds:
    if(write(nullfd, (void *) arg_ptr, sizeof(msqid_ds_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_msqid_ds", "unmapped");
      return;
    }

    msqid_ds_p = (struct msqid_ds *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_msqid_ds");
    xmlTextWriterWriteBase64(writer, (char *) msqid_ds_p, 0, sizeof(msqid_ds_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_sembuf:
    if(write(nullfd, (void *) arg_ptr, sizeof(sembuf_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_sembuf", "unmapped");
      return;
    }

    sembuf_p = (struct sembuf *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_sembuf");
    xmlTextWriterWriteBase64(writer, (char *) sembuf_p, 0, sizeof(sembuf_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_shmid_ds:
    if(write(nullfd, (void *) arg_ptr, sizeof(shmid_ds_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_shmid_ds", "unmapped");
      return;
    }

    shmid_ds_p = (struct shmid_ds *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_shmid_ds");
    xmlTextWriterWriteBase64(writer, (char *) shmid_ds_p, 0, sizeof(shmid_ds_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_mq_attr:
    if(write(nullfd, (void *) arg_ptr, sizeof(mq_attr_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_mq_attr", "unmapped");
      return;
    }

    mq_attr_p = (struct mq_attr *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_mq_attr");
    xmlTextWriterWriteBase64(writer, (char *) mq_attr_p, 0, sizeof(mq_attr_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG___sysctl_args:
    if(write(nullfd, (void *) arg_ptr, sizeof(__sysctl_args_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT___sysctl_args", "unmapped");
      return;
    }

    __sysctl_args_p = (struct __sysctl_args *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT___sysctl_args");
    xmlTextWriterWriteBase64(writer, (char *) __sysctl_args_p, 0, sizeof(__sysctl_args_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_robust_list_head:
    if(write(nullfd, (void *) arg_ptr, sizeof(robust_list_head_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_robust_list_head", "unmapped");
      return;
    }

    robust_list_head_p = (struct robust_list_head *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_robust_list_head");
    xmlTextWriterWriteBase64(writer, (char *) robust_list_head_p, 0, sizeof(robust_list_head_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_getcpu_cache:
    if(write(nullfd, (void *) arg_ptr, sizeof(getcpu_cache_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_getcpu_cache", "unmapped");
      return;
    }

    getcpu_cache_p = (struct getcpu_cache *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_getcpu_cache");
    xmlTextWriterWriteBase64(writer, (char *) getcpu_cache_p, 0, sizeof(getcpu_cache_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_perf_event_attr:
    if(write(nullfd, (void *) arg_ptr, sizeof(perf_event_attr_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_perf_event_attr", "unmapped");
      return;
    }

    perf_event_attr_p = (struct perf_event_attr *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_perf_event_attr");
    xmlTextWriterWriteBase64(writer, (char *) perf_event_attr_p, 0, sizeof(perf_event_attr_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_mmap_arg_struct:
    if(write(nullfd, (void *) arg_ptr, sizeof(mmap_arg_struct_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_mmap_arg_struct", "unmapped");
      return;
    }

    mmap_arg_struct_p = (struct mmap_arg_struct *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_mmap_arg_struct");
    xmlTextWriterWriteBase64(writer, (char *) mmap_arg_struct_p, 0, sizeof(mmap_arg_struct_s));
    xmlTextWriterEndElement(writer);

    break;

  case STRUCT_ARG_file_handle:
    if(write(nullfd, (void *) arg_ptr, sizeof(file_handle_s)) < 0) {
      xmlTextWriterWriteElement(writer, "STRUCT_file_handle", "unmapped");
      return;
    }

    file_handle_p = (struct file_handle *) arg_ptr;
    xmlTextWriterStartElement(writer, "STRUCT_file_handle");
    xmlTextWriterWriteBase64(writer, (char *) file_handle_p, 0, sizeof(file_handle_s));
    xmlTextWriterEndElement(writer);

    break;

  default:
    break;
  }
}
